{"ast":null,"code":"'use strict';\n\nmodule.exports = factory; // Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.\n\nfunction factory(type) {\n  return tokenize; // Tokenizer for a bound `type`.\n\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength; // Trim white space only lines.\n\n    if (!value) {\n      return tokens;\n    } // Expose on `eat`.\n\n\n    eat.now = now;\n    eat.file = self.file; // Sync initial offset.\n\n    updatePosition(''); // Iterate over `value`, and iterate over all tokenizers.  When one eats\n    // something, re-iterate with the remaining value.  If no tokenizer eats,\n    // something failed (should not happen) and an exception is thrown.\n\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name]; // Previously, we had constructs such as footnotes and YAML that used\n        // these properties.\n        // Those are now external (plus there are userland extensions), that may\n        // still use them.\n\n        if (method && (!method.onlyAtStart || self.atStart) && (!method.notInList || !self.inList) && (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {\n          valueLength = value.length;\n          method.apply(self, [eat, value]);\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n      /* istanbul ignore if */\n\n\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n    return tokens; // Update line, column, and offset based on `value`.\n\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    } // Get offset.  Called before the first character is eaten to retrieve the\n    // range’s offsets.\n\n\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1; // Done.  Called when the last character is eaten to retrieve the range’s\n      // offsets.\n\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n          pos++;\n        }\n\n        return indentation;\n      };\n    } // Get the current position.\n\n\n    function now() {\n      var pos = {\n        line: line,\n        column: column\n      };\n      pos.offset = self.toOffset(pos);\n      return pos;\n    } // Store position information for a node.\n\n\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    } // Throw when a value is incorrectly eaten.  This shouldn’t happen but will\n    // throw on new, incorrect rules.\n\n\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.slice(0, subvalue.length) !== subvalue) {\n        // Capture stack-trace.\n        self.file.fail(new Error('Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'), now());\n      }\n    } // Mark position and patch `node.position`.\n\n\n    function position() {\n      var before = now();\n      return update; // Add the position to a node.\n\n      function update(node, indent) {\n        var previous = node.position;\n        var start = previous ? previous.start : before;\n        var combined = [];\n        var n = previous && previous.end.line;\n        var l = before.line;\n        node.position = new Position(start); // If there was already a `position`, this node was merged.  Fixing\n        // `start` wasn’t hard, but the indent is different.  Especially\n        // because some information, the indent between `n` and `l` wasn’t\n        // tracked.  Luckily, that space is (should be?) empty, so we can\n        // safely check for it now.\n\n        if (previous && indent && previous.indent) {\n          combined = previous.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n        return node;\n      }\n    } // Add `node` to `parent`s children or to `tokens`.  Performs merges where\n    // possible.\n\n\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var previous = children[children.length - 1];\n      var fn;\n\n      if (previous && node.type === previous.type && (node.type === 'text' || node.type === 'blockquote') && mergeable(previous) && mergeable(node)) {\n        fn = node.type === 'text' ? mergeText : mergeBlockquote;\n        node = fn.call(self, previous, node);\n      }\n\n      if (node !== previous) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    } // Remove `subvalue` from `value`.  `subvalue` must be at the start of\n    // `value`.\n\n\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n      validateEat(subvalue);\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n      value = value.slice(subvalue.length);\n      updatePosition(subvalue);\n      indent = indent();\n      return apply; // Add the given arguments, add `position` to the returned node, and\n      // return the node.\n\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      } // Functions just like apply, but resets the content: the line and\n      // column are reversed, and the eaten value is re-added.   This is\n      // useful for nodes with a single type of content, such as lists and\n      // tables.  See `apply` above for what parameters are expected.\n\n\n      function reset() {\n        var node = apply.apply(null, arguments);\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return node;\n      } // Test the position, after eating, and reverse to a not-eaten state.\n\n\n      function test() {\n        var result = pos({});\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return result.position;\n      }\n    }\n  }\n} // Check whether a node is mergeable with adjacent nodes.\n\n\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end; // Only merge nodes which occupy the same size as their `value`.\n\n  return start.line !== end.line || end.column - start.column === node.value.length;\n} // Merge two text nodes: `node` into `prev`.\n\n\nfunction mergeText(previous, node) {\n  previous.value += node.value;\n  return previous;\n} // Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.\n\n\nfunction mergeBlockquote(previous, node) {\n  if (this.options.commonmark || this.options.gfm) {\n    return node;\n  }\n\n  previous.children = previous.children.concat(node.children);\n  return previous;\n}","map":{"version":3,"sources":["E:/Monirul AWS/PorzotokFrontend/node_modules/remark-parse/lib/tokenizer.js"],"names":["module","exports","factory","type","tokenize","value","location","self","offset","tokens","methods","tokenizers","line","column","index","length","method","name","matched","valueLength","eat","now","file","updatePosition","onlyAtStart","atStart","notInList","inList","notInBlock","inBlock","notInLink","inLink","apply","fail","Error","eof","subvalue","lastIndex","indexOf","getOffset","indentation","pos","last","push","toOffset","Position","start","end","validateEat","slice","position","before","update","node","indent","previous","combined","n","l","concat","add","parent","children","fn","mergeable","mergeText","mergeBlockquote","call","exitStart","current","reset","test","arguments","result","options","commonmark","gfm"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = factory\n\n// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.\nfunction factory(type) {\n  return tokenize\n\n  // Tokenizer for a bound `type`.\n  function tokenize(value, location) {\n    var self = this\n    var offset = self.offset\n    var tokens = []\n    var methods = self[type + 'Methods']\n    var tokenizers = self[type + 'Tokenizers']\n    var line = location.line\n    var column = location.column\n    var index\n    var length\n    var method\n    var name\n    var matched\n    var valueLength\n\n    // Trim white space only lines.\n    if (!value) {\n      return tokens\n    }\n\n    // Expose on `eat`.\n    eat.now = now\n    eat.file = self.file\n\n    // Sync initial offset.\n    updatePosition('')\n\n    // Iterate over `value`, and iterate over all tokenizers.  When one eats\n    // something, re-iterate with the remaining value.  If no tokenizer eats,\n    // something failed (should not happen) and an exception is thrown.\n    while (value) {\n      index = -1\n      length = methods.length\n      matched = false\n\n      while (++index < length) {\n        name = methods[index]\n        method = tokenizers[name]\n\n        // Previously, we had constructs such as footnotes and YAML that used\n        // these properties.\n        // Those are now external (plus there are userland extensions), that may\n        // still use them.\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          /* istanbul ignore next */ (!method.notInList || !self.inList) &&\n          /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length\n\n          method.apply(self, [eat, value])\n\n          matched = valueLength !== value.length\n\n          if (matched) {\n            break\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now())\n      }\n    }\n\n    self.eof = now()\n\n    return tokens\n\n    // Update line, column, and offset based on `value`.\n    function updatePosition(subvalue) {\n      var lastIndex = -1\n      var index = subvalue.indexOf('\\n')\n\n      while (index !== -1) {\n        line++\n        lastIndex = index\n        index = subvalue.indexOf('\\n', index + 1)\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length\n      } else {\n        column = subvalue.length - lastIndex\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line]\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1\n        }\n      }\n    }\n\n    // Get offset.  Called before the first character is eaten to retrieve the\n    // range’s offsets.\n    function getOffset() {\n      var indentation = []\n      var pos = line + 1\n\n      // Done.  Called when the last character is eaten to retrieve the range’s\n      // offsets.\n      return function () {\n        var last = line + 1\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1)\n\n          pos++\n        }\n\n        return indentation\n      }\n    }\n\n    // Get the current position.\n    function now() {\n      var pos = {line: line, column: column}\n\n      pos.offset = self.toOffset(pos)\n\n      return pos\n    }\n\n    // Store position information for a node.\n    function Position(start) {\n      this.start = start\n      this.end = now()\n    }\n\n    // Throw when a value is incorrectly eaten.  This shouldn’t happen but will\n    // throw on new, incorrect rules.\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.slice(0, subvalue.length) !== subvalue) {\n        // Capture stack-trace.\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'\n          ),\n          now()\n        )\n      }\n    }\n\n    // Mark position and patch `node.position`.\n    function position() {\n      var before = now()\n\n      return update\n\n      // Add the position to a node.\n      function update(node, indent) {\n        var previous = node.position\n        var start = previous ? previous.start : before\n        var combined = []\n        var n = previous && previous.end.line\n        var l = before.line\n\n        node.position = new Position(start)\n\n        // If there was already a `position`, this node was merged.  Fixing\n        // `start` wasn’t hard, but the indent is different.  Especially\n        // because some information, the indent between `n` and `l` wasn’t\n        // tracked.  Luckily, that space is (should be?) empty, so we can\n        // safely check for it now.\n        if (previous && indent && previous.indent) {\n          combined = previous.indent\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1)\n            }\n\n            combined.push(before.column)\n          }\n\n          indent = combined.concat(indent)\n        }\n\n        node.position.indent = indent || []\n\n        return node\n      }\n    }\n\n    // Add `node` to `parent`s children or to `tokens`.  Performs merges where\n    // possible.\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens\n      var previous = children[children.length - 1]\n      var fn\n\n      if (\n        previous &&\n        node.type === previous.type &&\n        (node.type === 'text' || node.type === 'blockquote') &&\n        mergeable(previous) &&\n        mergeable(node)\n      ) {\n        fn = node.type === 'text' ? mergeText : mergeBlockquote\n        node = fn.call(self, previous, node)\n      }\n\n      if (node !== previous) {\n        children.push(node)\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart()\n      }\n\n      return node\n    }\n\n    // Remove `subvalue` from `value`.  `subvalue` must be at the start of\n    // `value`.\n    function eat(subvalue) {\n      var indent = getOffset()\n      var pos = position()\n      var current = now()\n\n      validateEat(subvalue)\n\n      apply.reset = reset\n      reset.test = test\n      apply.test = test\n\n      value = value.slice(subvalue.length)\n\n      updatePosition(subvalue)\n\n      indent = indent()\n\n      return apply\n\n      // Add the given arguments, add `position` to the returned node, and\n      // return the node.\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent)\n      }\n\n      // Functions just like apply, but resets the content: the line and\n      // column are reversed, and the eaten value is re-added.   This is\n      // useful for nodes with a single type of content, such as lists and\n      // tables.  See `apply` above for what parameters are expected.\n      function reset() {\n        var node = apply.apply(null, arguments)\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return node\n      }\n\n      // Test the position, after eating, and reverse to a not-eaten state.\n      function test() {\n        var result = pos({})\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return result.position\n      }\n    }\n  }\n}\n\n// Check whether a node is mergeable with adjacent nodes.\nfunction mergeable(node) {\n  var start\n  var end\n\n  if (node.type !== 'text' || !node.position) {\n    return true\n  }\n\n  start = node.position.start\n  end = node.position.end\n\n  // Only merge nodes which occupy the same size as their `value`.\n  return (\n    start.line !== end.line || end.column - start.column === node.value.length\n  )\n}\n\n// Merge two text nodes: `node` into `prev`.\nfunction mergeText(previous, node) {\n  previous.value += node.value\n\n  return previous\n}\n\n// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.\nfunction mergeBlockquote(previous, node) {\n  if (this.options.commonmark || this.options.gfm) {\n    return node\n  }\n\n  previous.children = previous.children.concat(node.children)\n\n  return previous\n}\n"]},"metadata":{},"sourceType":"script"}