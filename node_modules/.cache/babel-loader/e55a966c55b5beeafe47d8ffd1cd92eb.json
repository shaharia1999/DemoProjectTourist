{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\nvar tab = '\\t';\nvar lineFeed = '\\n';\nvar space = ' ';\nvar dash = '-';\nvar colon = ':';\nvar backslash = '\\\\';\nvar verticalBar = '|';\nvar minColumns = 1;\nvar minRows = 2;\nvar left = 'left';\nvar center = 'center';\nvar right = 'right';\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first; // Exit when not in gfm-mode.\n\n  if (!self.options.gfm) {\n    return;\n  } // Get the rows.\n  // Detecting tables soon is hard, so there are some checks for performance\n  // here, such as the minimum number of rows, and allowed characters in the\n  // alignment row.\n\n\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(lineFeed, index);\n    pipeIndex = value.indexOf(verticalBar, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < minRows) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  } // Parse the alignment row.\n\n\n  subvalue = lines.join(lineFeed);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === verticalBar) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === dash) {\n      hasDash = true;\n      alignment = alignment || null;\n    } else if (character === colon) {\n      if (alignment === left) {\n        alignment = center;\n      } else if (hasDash && alignment === null) {\n        alignment = right;\n      } else {\n        alignment = left;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  } // Exit when without enough columns.\n\n\n  if (align.length < minColumns) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  } // Parse the rows.\n\n\n  position = -1;\n  rows = [];\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {\n      type: 'tableRow',\n      children: []\n    }; // Eat a newline character when this is not the first row.\n\n    if (position) {\n      eat(lineFeed);\n    } // Eat the row.\n\n\n    eat(line).reset(row, table);\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === tab || character === space) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === verticalBar) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, -1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === backslash && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n      }\n\n      preamble = false;\n      index++;\n    } // Eat the alignment row.\n\n\n    if (!position) {\n      eat(lineFeed + alignments);\n    }\n  }\n\n  return table;\n}","map":{"version":3,"sources":["F:/PorzotokFrontend/node_modules/remark-parse/lib/tokenize/table.js"],"names":["whitespace","require","module","exports","table","tab","lineFeed","space","dash","colon","backslash","verticalBar","minColumns","minRows","left","center","right","eat","value","silent","self","index","alignments","alignment","subvalue","row","length","lines","queue","character","hasDash","align","cell","preamble","now","position","lineCount","line","rows","lineIndex","pipeIndex","first","options","gfm","indexOf","push","slice","join","splice","charAt","reset","type","children","tokenizeInline"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nvar whitespace = require('is-whitespace-character')\r\n\r\nmodule.exports = table\r\n\r\nvar tab = '\\t'\r\nvar lineFeed = '\\n'\r\nvar space = ' '\r\nvar dash = '-'\r\nvar colon = ':'\r\nvar backslash = '\\\\'\r\nvar verticalBar = '|'\r\n\r\nvar minColumns = 1\r\nvar minRows = 2\r\n\r\nvar left = 'left'\r\nvar center = 'center'\r\nvar right = 'right'\r\n\r\nfunction table(eat, value, silent) {\r\n  var self = this\r\n  var index\r\n  var alignments\r\n  var alignment\r\n  var subvalue\r\n  var row\r\n  var length\r\n  var lines\r\n  var queue\r\n  var character\r\n  var hasDash\r\n  var align\r\n  var cell\r\n  var preamble\r\n  var now\r\n  var position\r\n  var lineCount\r\n  var line\r\n  var rows\r\n  var table\r\n  var lineIndex\r\n  var pipeIndex\r\n  var first\r\n\r\n  // Exit when not in gfm-mode.\r\n  if (!self.options.gfm) {\r\n    return\r\n  }\r\n\r\n  // Get the rows.\r\n  // Detecting tables soon is hard, so there are some checks for performance\r\n  // here, such as the minimum number of rows, and allowed characters in the\r\n  // alignment row.\r\n  index = 0\r\n  lineCount = 0\r\n  length = value.length + 1\r\n  lines = []\r\n\r\n  while (index < length) {\r\n    lineIndex = value.indexOf(lineFeed, index)\r\n    pipeIndex = value.indexOf(verticalBar, index + 1)\r\n\r\n    if (lineIndex === -1) {\r\n      lineIndex = value.length\r\n    }\r\n\r\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\r\n      if (lineCount < minRows) {\r\n        return\r\n      }\r\n\r\n      break\r\n    }\r\n\r\n    lines.push(value.slice(index, lineIndex))\r\n    lineCount++\r\n    index = lineIndex + 1\r\n  }\r\n\r\n  // Parse the alignment row.\r\n  subvalue = lines.join(lineFeed)\r\n  alignments = lines.splice(1, 1)[0] || []\r\n  index = 0\r\n  length = alignments.length\r\n  lineCount--\r\n  alignment = false\r\n  align = []\r\n\r\n  while (index < length) {\r\n    character = alignments.charAt(index)\r\n\r\n    if (character === verticalBar) {\r\n      hasDash = null\r\n\r\n      if (alignment === false) {\r\n        if (first === false) {\r\n          return\r\n        }\r\n      } else {\r\n        align.push(alignment)\r\n        alignment = false\r\n      }\r\n\r\n      first = false\r\n    } else if (character === dash) {\r\n      hasDash = true\r\n      alignment = alignment || null\r\n    } else if (character === colon) {\r\n      if (alignment === left) {\r\n        alignment = center\r\n      } else if (hasDash && alignment === null) {\r\n        alignment = right\r\n      } else {\r\n        alignment = left\r\n      }\r\n    } else if (!whitespace(character)) {\r\n      return\r\n    }\r\n\r\n    index++\r\n  }\r\n\r\n  if (alignment !== false) {\r\n    align.push(alignment)\r\n  }\r\n\r\n  // Exit when without enough columns.\r\n  if (align.length < minColumns) {\r\n    return\r\n  }\r\n\r\n  /* istanbul ignore if - never used (yet) */\r\n  if (silent) {\r\n    return true\r\n  }\r\n\r\n  // Parse the rows.\r\n  position = -1\r\n  rows = []\r\n\r\n  table = eat(subvalue).reset({type: 'table', align: align, children: rows})\r\n\r\n  while (++position < lineCount) {\r\n    line = lines[position]\r\n    row = {type: 'tableRow', children: []}\r\n\r\n    // Eat a newline character when this is not the first row.\r\n    if (position) {\r\n      eat(lineFeed)\r\n    }\r\n\r\n    // Eat the row.\r\n    eat(line).reset(row, table)\r\n\r\n    length = line.length + 1\r\n    index = 0\r\n    queue = ''\r\n    cell = ''\r\n    preamble = true\r\n\r\n    while (index < length) {\r\n      character = line.charAt(index)\r\n\r\n      if (character === tab || character === space) {\r\n        if (cell) {\r\n          queue += character\r\n        } else {\r\n          eat(character)\r\n        }\r\n\r\n        index++\r\n        continue\r\n      }\r\n\r\n      if (character === '' || character === verticalBar) {\r\n        if (preamble) {\r\n          eat(character)\r\n        } else {\r\n          if ((cell || character) && !preamble) {\r\n            subvalue = cell\r\n\r\n            if (queue.length > 1) {\r\n              if (character) {\r\n                subvalue += queue.slice(0, -1)\r\n                queue = queue.charAt(queue.length - 1)\r\n              } else {\r\n                subvalue += queue\r\n                queue = ''\r\n              }\r\n            }\r\n\r\n            now = eat.now()\r\n\r\n            eat(subvalue)(\r\n              {type: 'tableCell', children: self.tokenizeInline(cell, now)},\r\n              row\r\n            )\r\n          }\r\n\r\n          eat(queue + character)\r\n\r\n          queue = ''\r\n          cell = ''\r\n        }\r\n      } else {\r\n        if (queue) {\r\n          cell += queue\r\n          queue = ''\r\n        }\r\n\r\n        cell += character\r\n\r\n        if (character === backslash && index !== length - 2) {\r\n          cell += line.charAt(index + 1)\r\n          index++\r\n        }\r\n      }\r\n\r\n      preamble = false\r\n      index++\r\n    }\r\n\r\n    // Eat the alignment row.\r\n    if (!position) {\r\n      eat(lineFeed + alignments)\r\n    }\r\n  }\r\n\r\n  return table\r\n}\r\n"]},"metadata":{},"sourceType":"script"}