{"ast":null,"code":"'use strict';\n\nvar ccount = require('ccount');\n\nvar decode = require('parse-entities');\n\nvar decimal = require('is-decimal');\n\nvar alphabetical = require('is-alphabetical');\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/url');\n\nmodule.exports = url;\nurl.locator = locate;\nurl.notInLink = true;\nvar exclamationMark = 33; // '!'\n\nvar ampersand = 38; // '&'\n\nvar rightParenthesis = 41; // ')'\n\nvar asterisk = 42; // '*'\n\nvar comma = 44; // ','\n\nvar dash = 45; // '-'\n\nvar dot = 46; // '.'\n\nvar colon = 58; // ':'\n\nvar semicolon = 59; // ';'\n\nvar questionMark = 63; // '?'\n\nvar lessThan = 60; // '<'\n\nvar underscore = 95; // '_'\n\nvar tilde = 126; // '~'\n\nvar leftParenthesisCharacter = '(';\nvar rightParenthesisCharacter = ')';\n\nfunction url(eat, value, silent) {\n  var self = this;\n  var gfm = self.options.gfm;\n  var tokenizers = self.inlineTokenizers;\n  var length = value.length;\n  var previousDot = -1;\n  var protocolless = false;\n  var dots;\n  var lastTwoPartsStart;\n  var start;\n  var index;\n  var pathStart;\n  var path;\n  var code;\n  var end;\n  var leftCount;\n  var rightCount;\n  var content;\n  var children;\n  var url;\n  var exit;\n\n  if (!gfm) {\n    return;\n  } // `WWW.` doesn’t work.\n\n\n  if (value.slice(0, 4) === 'www.') {\n    protocolless = true;\n    index = 4;\n  } else if (value.slice(0, 7).toLowerCase() === 'http://') {\n    index = 7;\n  } else if (value.slice(0, 8).toLowerCase() === 'https://') {\n    index = 8;\n  } else {\n    return;\n  } // Act as if the starting boundary is a dot.\n\n\n  previousDot = index - 1; // Parse a valid domain.\n\n  start = index;\n  dots = [];\n\n  while (index < length) {\n    code = value.charCodeAt(index);\n\n    if (code === dot) {\n      // Dots may not appear after each other.\n      if (previousDot === index - 1) {\n        break;\n      }\n\n      dots.push(index);\n      previousDot = index;\n      index++;\n      continue;\n    }\n\n    if (decimal(code) || alphabetical(code) || code === dash || code === underscore) {\n      index++;\n      continue;\n    }\n\n    break;\n  } // Ignore a final dot:\n\n\n  if (code === dot) {\n    dots.pop();\n    index--;\n  } // If there are not dots, exit.\n\n\n  if (dots[0] === undefined) {\n    return;\n  } // If there is an underscore in the last two domain parts, exit:\n  // `www.example.c_m` and `www.ex_ample.com` are not OK, but\n  // `www.sub_domain.example.com` is.\n\n\n  lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;\n\n  if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  end = index;\n  pathStart = index; // Parse a path.\n\n  while (index < length) {\n    code = value.charCodeAt(index);\n\n    if (whitespace(code) || code === lessThan) {\n      break;\n    }\n\n    index++;\n\n    if (code === exclamationMark || code === asterisk || code === comma || code === dot || code === colon || code === questionMark || code === underscore || code === tilde) {// Empty\n    } else {\n      end = index;\n    }\n  }\n\n  index = end; // If the path ends in a closing paren, and the count of closing parens is\n  // higher than the opening count, then remove the supefluous closing parens.\n\n  if (value.charCodeAt(index - 1) === rightParenthesis) {\n    path = value.slice(pathStart, index);\n    leftCount = ccount(path, leftParenthesisCharacter);\n    rightCount = ccount(path, rightParenthesisCharacter);\n\n    while (rightCount > leftCount) {\n      index = pathStart + path.lastIndexOf(rightParenthesisCharacter);\n      path = value.slice(pathStart, index);\n      rightCount--;\n    }\n  }\n\n  if (value.charCodeAt(index - 1) === semicolon) {\n    // GitHub doesn’t document this, but final semicolons aren’t paret of the\n    // URL either.\n    index--; // // If the path ends in what looks like an entity, it’s not part of the path.\n\n    if (alphabetical(value.charCodeAt(index - 1))) {\n      end = index - 2;\n\n      while (alphabetical(value.charCodeAt(end))) {\n        end--;\n      }\n\n      if (value.charCodeAt(end) === ampersand) {\n        index = end;\n      }\n    }\n  }\n\n  content = value.slice(0, index);\n  url = decode(content, {\n    nonTerminated: false\n  });\n\n  if (protocolless) {\n    url = 'http://' + url;\n  }\n\n  exit = self.enterLink(); // Temporarily remove all tokenizers except text in url.\n\n  self.inlineTokenizers = {\n    text: tokenizers.text\n  };\n  children = self.tokenizeInline(content, eat.now());\n  self.inlineTokenizers = tokenizers;\n  exit();\n  return eat(content)({\n    type: 'link',\n    title: null,\n    url: url,\n    children: children\n  });\n}","map":{"version":3,"sources":["D:/PorzotokFrontend/node_modules/remark-parse/lib/tokenize/url.js"],"names":["ccount","require","decode","decimal","alphabetical","whitespace","locate","module","exports","url","locator","notInLink","exclamationMark","ampersand","rightParenthesis","asterisk","comma","dash","dot","colon","semicolon","questionMark","lessThan","underscore","tilde","leftParenthesisCharacter","rightParenthesisCharacter","eat","value","silent","self","gfm","options","tokenizers","inlineTokenizers","length","previousDot","protocolless","dots","lastTwoPartsStart","start","index","pathStart","path","code","end","leftCount","rightCount","content","children","exit","slice","toLowerCase","charCodeAt","push","pop","undefined","indexOf","lastIndexOf","nonTerminated","enterLink","text","tokenizeInline","now","type","title"],"mappings":"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","sourcesContent":["'use strict'\n\nvar ccount = require('ccount')\nvar decode = require('parse-entities')\nvar decimal = require('is-decimal')\nvar alphabetical = require('is-alphabetical')\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/url')\n\nmodule.exports = url\nurl.locator = locate\nurl.notInLink = true\n\nvar exclamationMark = 33 // '!'\nvar ampersand = 38 // '&'\nvar rightParenthesis = 41 // ')'\nvar asterisk = 42 // '*'\nvar comma = 44 // ','\nvar dash = 45 // '-'\nvar dot = 46 // '.'\nvar colon = 58 // ':'\nvar semicolon = 59 // ';'\nvar questionMark = 63 // '?'\nvar lessThan = 60 // '<'\nvar underscore = 95 // '_'\nvar tilde = 126 // '~'\n\nvar leftParenthesisCharacter = '('\nvar rightParenthesisCharacter = ')'\n\nfunction url(eat, value, silent) {\n  var self = this\n  var gfm = self.options.gfm\n  var tokenizers = self.inlineTokenizers\n  var length = value.length\n  var previousDot = -1\n  var protocolless = false\n  var dots\n  var lastTwoPartsStart\n  var start\n  var index\n  var pathStart\n  var path\n  var code\n  var end\n  var leftCount\n  var rightCount\n  var content\n  var children\n  var url\n  var exit\n\n  if (!gfm) {\n    return\n  }\n\n  // `WWW.` doesn’t work.\n  if (value.slice(0, 4) === 'www.') {\n    protocolless = true\n    index = 4\n  } else if (value.slice(0, 7).toLowerCase() === 'http://') {\n    index = 7\n  } else if (value.slice(0, 8).toLowerCase() === 'https://') {\n    index = 8\n  } else {\n    return\n  }\n\n  // Act as if the starting boundary is a dot.\n  previousDot = index - 1\n\n  // Parse a valid domain.\n  start = index\n  dots = []\n\n  while (index < length) {\n    code = value.charCodeAt(index)\n\n    if (code === dot) {\n      // Dots may not appear after each other.\n      if (previousDot === index - 1) {\n        break\n      }\n\n      dots.push(index)\n      previousDot = index\n      index++\n      continue\n    }\n\n    if (\n      decimal(code) ||\n      alphabetical(code) ||\n      code === dash ||\n      code === underscore\n    ) {\n      index++\n      continue\n    }\n\n    break\n  }\n\n  // Ignore a final dot:\n  if (code === dot) {\n    dots.pop()\n    index--\n  }\n\n  // If there are not dots, exit.\n  if (dots[0] === undefined) {\n    return\n  }\n\n  // If there is an underscore in the last two domain parts, exit:\n  // `www.example.c_m` and `www.ex_ample.com` are not OK, but\n  // `www.sub_domain.example.com` is.\n  lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1\n\n  if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  end = index\n  pathStart = index\n\n  // Parse a path.\n  while (index < length) {\n    code = value.charCodeAt(index)\n\n    if (whitespace(code) || code === lessThan) {\n      break\n    }\n\n    index++\n\n    if (\n      code === exclamationMark ||\n      code === asterisk ||\n      code === comma ||\n      code === dot ||\n      code === colon ||\n      code === questionMark ||\n      code === underscore ||\n      code === tilde\n    ) {\n      // Empty\n    } else {\n      end = index\n    }\n  }\n\n  index = end\n\n  // If the path ends in a closing paren, and the count of closing parens is\n  // higher than the opening count, then remove the supefluous closing parens.\n  if (value.charCodeAt(index - 1) === rightParenthesis) {\n    path = value.slice(pathStart, index)\n    leftCount = ccount(path, leftParenthesisCharacter)\n    rightCount = ccount(path, rightParenthesisCharacter)\n\n    while (rightCount > leftCount) {\n      index = pathStart + path.lastIndexOf(rightParenthesisCharacter)\n      path = value.slice(pathStart, index)\n      rightCount--\n    }\n  }\n\n  if (value.charCodeAt(index - 1) === semicolon) {\n    // GitHub doesn’t document this, but final semicolons aren’t paret of the\n    // URL either.\n    index--\n\n    // // If the path ends in what looks like an entity, it’s not part of the path.\n    if (alphabetical(value.charCodeAt(index - 1))) {\n      end = index - 2\n\n      while (alphabetical(value.charCodeAt(end))) {\n        end--\n      }\n\n      if (value.charCodeAt(end) === ampersand) {\n        index = end\n      }\n    }\n  }\n\n  content = value.slice(0, index)\n  url = decode(content, {nonTerminated: false})\n\n  if (protocolless) {\n    url = 'http://' + url\n  }\n\n  exit = self.enterLink()\n\n  // Temporarily remove all tokenizers except text in url.\n  self.inlineTokenizers = {text: tokenizers.text}\n  children = self.tokenizeInline(content, eat.now())\n  self.inlineTokenizers = tokenizers\n\n  exit()\n\n  return eat(content)({type: 'link', title: null, url: url, children: children})\n}\n"]},"metadata":{},"sourceType":"script"}