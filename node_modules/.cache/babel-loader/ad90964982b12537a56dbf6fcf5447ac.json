{"ast":null,"code":"'use strict';\n\nmodule.exports = setextHeading;\nvar lineFeed = '\\n';\nvar tab = '\\t';\nvar space = ' ';\nvar equalsTo = '=';\nvar dash = '-';\nvar maxIndent = 3;\nvar equalsToDepth = 1;\nvar dashDepth = 2;\n\nfunction setextHeading(eat, value, silent) {\n  var self = this;\n  var now = eat.now();\n  var length = value.length;\n  var index = -1;\n  var subvalue = '';\n  var content;\n  var queue;\n  var character;\n  var marker;\n  var depth; // Eat initial indentation.\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== space || index >= maxIndent) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  } // Eat content.\n\n\n  content = '';\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === lineFeed) {\n      index--;\n      break;\n    }\n\n    if (character === space || character === tab) {\n      queue += character;\n    } else {\n      content += queue + character;\n      queue = '';\n    }\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue; // Ensure the content is followed by a newline and a valid marker.\n\n  character = value.charAt(++index);\n  marker = value.charAt(++index);\n\n  if (character !== lineFeed || marker !== equalsTo && marker !== dash) {\n    return;\n  }\n\n  subvalue += character; // Eat Setext-line.\n\n  queue = marker;\n  depth = marker === equalsTo ? equalsToDepth : dashDepth;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      if (character !== lineFeed) {\n        return;\n      }\n\n      index--;\n      break;\n    }\n\n    queue += character;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  return eat(subvalue + queue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}","map":{"version":3,"sources":["F:/PorzotokFrontend/node_modules/remark-parse/lib/tokenize/heading-setext.js"],"names":["module","exports","setextHeading","lineFeed","tab","space","equalsTo","dash","maxIndent","equalsToDepth","dashDepth","eat","value","silent","self","now","length","index","subvalue","content","queue","character","marker","depth","charAt","column","offset","type","children","tokenizeInline"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = setextHeading\r\n\r\nvar lineFeed = '\\n'\r\nvar tab = '\\t'\r\nvar space = ' '\r\nvar equalsTo = '='\r\nvar dash = '-'\r\n\r\nvar maxIndent = 3\r\n\r\nvar equalsToDepth = 1\r\nvar dashDepth = 2\r\n\r\nfunction setextHeading(eat, value, silent) {\r\n  var self = this\r\n  var now = eat.now()\r\n  var length = value.length\r\n  var index = -1\r\n  var subvalue = ''\r\n  var content\r\n  var queue\r\n  var character\r\n  var marker\r\n  var depth\r\n\r\n  // Eat initial indentation.\r\n  while (++index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (character !== space || index >= maxIndent) {\r\n      index--\r\n      break\r\n    }\r\n\r\n    subvalue += character\r\n  }\r\n\r\n  // Eat content.\r\n  content = ''\r\n  queue = ''\r\n\r\n  while (++index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (character === lineFeed) {\r\n      index--\r\n      break\r\n    }\r\n\r\n    if (character === space || character === tab) {\r\n      queue += character\r\n    } else {\r\n      content += queue + character\r\n      queue = ''\r\n    }\r\n  }\r\n\r\n  now.column += subvalue.length\r\n  now.offset += subvalue.length\r\n  subvalue += content + queue\r\n\r\n  // Ensure the content is followed by a newline and a valid marker.\r\n  character = value.charAt(++index)\r\n  marker = value.charAt(++index)\r\n\r\n  if (character !== lineFeed || (marker !== equalsTo && marker !== dash)) {\r\n    return\r\n  }\r\n\r\n  subvalue += character\r\n\r\n  // Eat Setext-line.\r\n  queue = marker\r\n  depth = marker === equalsTo ? equalsToDepth : dashDepth\r\n\r\n  while (++index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (character !== marker) {\r\n      if (character !== lineFeed) {\r\n        return\r\n      }\r\n\r\n      index--\r\n      break\r\n    }\r\n\r\n    queue += character\r\n  }\r\n\r\n  if (silent) {\r\n    return true\r\n  }\r\n\r\n  return eat(subvalue + queue)({\r\n    type: 'heading',\r\n    depth: depth,\r\n    children: self.tokenizeInline(content, now)\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}