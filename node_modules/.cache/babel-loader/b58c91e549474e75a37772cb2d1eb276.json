{"ast":null,"code":"'use strict';\n\nvar locate = require('../locate/code-inline');\n\nmodule.exports = inlineCode;\ninlineCode.locator = locate;\nvar lineFeed = 10; //  '\\n'\n\nvar space = 32; // ' '\n\nvar graveAccent = 96; //  '`'\n\nfunction inlineCode(eat, value, silent) {\n  var length = value.length;\n  var index = 0;\n  var openingFenceEnd;\n  var closingFenceStart;\n  var closingFenceEnd;\n  var code;\n  var next;\n  var found;\n\n  while (index < length) {\n    if (value.charCodeAt(index) !== graveAccent) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (index === 0 || index === length) {\n    return;\n  }\n\n  openingFenceEnd = index;\n  next = value.charCodeAt(index);\n\n  while (index < length) {\n    code = next;\n    next = value.charCodeAt(index + 1);\n\n    if (code === graveAccent) {\n      if (closingFenceStart === undefined) {\n        closingFenceStart = index;\n      }\n\n      closingFenceEnd = index + 1;\n\n      if (next !== graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {\n        found = true;\n        break;\n      }\n    } else if (closingFenceStart !== undefined) {\n      closingFenceStart = undefined;\n      closingFenceEnd = undefined;\n    }\n\n    index++;\n  }\n\n  if (!found) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  } // Remove the initial and final space (or line feed), iff they exist and there\n  // are non-space characters in the content.\n\n\n  index = openingFenceEnd;\n  length = closingFenceStart;\n  code = value.charCodeAt(index);\n  next = value.charCodeAt(length - 1);\n  found = false;\n\n  if (length - index > 2 && (code === space || code === lineFeed) && (next === space || next === lineFeed)) {\n    index++;\n    length--;\n\n    while (index < length) {\n      code = value.charCodeAt(index);\n\n      if (code !== space && code !== lineFeed) {\n        found = true;\n        break;\n      }\n\n      index++;\n    }\n\n    if (found === true) {\n      openingFenceEnd++;\n      closingFenceStart--;\n    }\n  }\n\n  return eat(value.slice(0, closingFenceEnd))({\n    type: 'inlineCode',\n    value: value.slice(openingFenceEnd, closingFenceStart)\n  });\n}","map":{"version":3,"sources":["F:/PorzotokFrontend/node_modules/remark-parse/lib/tokenize/code-inline.js"],"names":["locate","require","module","exports","inlineCode","locator","lineFeed","space","graveAccent","eat","value","silent","length","index","openingFenceEnd","closingFenceStart","closingFenceEnd","code","next","found","charCodeAt","undefined","slice","type"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nvar locate = require('../locate/code-inline')\r\n\r\nmodule.exports = inlineCode\r\ninlineCode.locator = locate\r\n\r\nvar lineFeed = 10 //  '\\n'\r\nvar space = 32 // ' '\r\nvar graveAccent = 96 //  '`'\r\n\r\nfunction inlineCode(eat, value, silent) {\r\n  var length = value.length\r\n  var index = 0\r\n  var openingFenceEnd\r\n  var closingFenceStart\r\n  var closingFenceEnd\r\n  var code\r\n  var next\r\n  var found\r\n\r\n  while (index < length) {\r\n    if (value.charCodeAt(index) !== graveAccent) {\r\n      break\r\n    }\r\n\r\n    index++\r\n  }\r\n\r\n  if (index === 0 || index === length) {\r\n    return\r\n  }\r\n\r\n  openingFenceEnd = index\r\n  next = value.charCodeAt(index)\r\n\r\n  while (index < length) {\r\n    code = next\r\n    next = value.charCodeAt(index + 1)\r\n\r\n    if (code === graveAccent) {\r\n      if (closingFenceStart === undefined) {\r\n        closingFenceStart = index\r\n      }\r\n\r\n      closingFenceEnd = index + 1\r\n\r\n      if (\r\n        next !== graveAccent &&\r\n        closingFenceEnd - closingFenceStart === openingFenceEnd\r\n      ) {\r\n        found = true\r\n        break\r\n      }\r\n    } else if (closingFenceStart !== undefined) {\r\n      closingFenceStart = undefined\r\n      closingFenceEnd = undefined\r\n    }\r\n\r\n    index++\r\n  }\r\n\r\n  if (!found) {\r\n    return\r\n  }\r\n\r\n  /* istanbul ignore if - never used (yet) */\r\n  if (silent) {\r\n    return true\r\n  }\r\n\r\n  // Remove the initial and final space (or line feed), iff they exist and there\r\n  // are non-space characters in the content.\r\n  index = openingFenceEnd\r\n  length = closingFenceStart\r\n  code = value.charCodeAt(index)\r\n  next = value.charCodeAt(length - 1)\r\n  found = false\r\n\r\n  if (\r\n    length - index > 2 &&\r\n    (code === space || code === lineFeed) &&\r\n    (next === space || next === lineFeed)\r\n  ) {\r\n    index++\r\n    length--\r\n\r\n    while (index < length) {\r\n      code = value.charCodeAt(index)\r\n\r\n      if (code !== space && code !== lineFeed) {\r\n        found = true\r\n        break\r\n      }\r\n\r\n      index++\r\n    }\r\n\r\n    if (found === true) {\r\n      openingFenceEnd++\r\n      closingFenceStart--\r\n    }\r\n  }\r\n\r\n  return eat(value.slice(0, closingFenceEnd))({\r\n    type: 'inlineCode',\r\n    value: value.slice(openingFenceEnd, closingFenceStart)\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}