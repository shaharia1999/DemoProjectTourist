{"ast":null,"code":"'use strict';\n\nmodule.exports = atxHeading;\nvar lineFeed = '\\n';\nvar tab = '\\t';\nvar space = ' ';\nvar numberSign = '#';\nvar maxFenceCount = 6;\n\nfunction atxHeading(eat, value, silent) {\n  var self = this;\n  var pedantic = self.options.pedantic;\n  var length = value.length + 1;\n  var index = -1;\n  var now = eat.now();\n  var subvalue = '';\n  var content = '';\n  var character;\n  var queue;\n  var depth; // Eat initial spacing.\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== space && character !== tab) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  } // Eat hashes.\n\n\n  depth = 0;\n\n  while (++index <= length) {\n    character = value.charAt(index);\n\n    if (character !== numberSign) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n    depth++;\n  }\n\n  if (depth > maxFenceCount) {\n    return;\n  }\n\n  if (!depth || !pedantic && value.charAt(index + 1) === numberSign) {\n    return;\n  }\n\n  length = value.length + 1; // Eat intermediate white-space.\n\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== space && character !== tab) {\n      index--;\n      break;\n    }\n\n    queue += character;\n  } // Exit when not in pedantic mode without spacing.\n\n\n  if (!pedantic && queue.length === 0 && character && character !== lineFeed) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  } // Eat content.\n\n\n  subvalue += queue;\n  queue = '';\n  content = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (!character || character === lineFeed) {\n      break;\n    }\n\n    if (character !== space && character !== tab && character !== numberSign) {\n      content += queue + character;\n      queue = '';\n      continue;\n    }\n\n    while (character === space || character === tab) {\n      queue += character;\n      character = value.charAt(++index);\n    } // `#` without a queue is part of the content.\n\n\n    if (!pedantic && content && !queue && character === numberSign) {\n      content += character;\n      continue;\n    }\n\n    while (character === numberSign) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    while (character === space || character === tab) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    index--;\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue;\n  return eat(subvalue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}","map":{"version":3,"sources":["D:/PorzotokFrontend/node_modules/remark-parse/lib/tokenize/heading-atx.js"],"names":["module","exports","atxHeading","lineFeed","tab","space","numberSign","maxFenceCount","eat","value","silent","self","pedantic","options","length","index","now","subvalue","content","character","queue","depth","charAt","column","offset","type","children","tokenizeInline"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = atxHeading\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar numberSign = '#'\n\nvar maxFenceCount = 6\n\nfunction atxHeading(eat, value, silent) {\n  var self = this\n  var pedantic = self.options.pedantic\n  var length = value.length + 1\n  var index = -1\n  var now = eat.now()\n  var subvalue = ''\n  var content = ''\n  var character\n  var queue\n  var depth\n\n  // Eat initial spacing.\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      index--\n      break\n    }\n\n    subvalue += character\n  }\n\n  // Eat hashes.\n  depth = 0\n\n  while (++index <= length) {\n    character = value.charAt(index)\n\n    if (character !== numberSign) {\n      index--\n      break\n    }\n\n    subvalue += character\n    depth++\n  }\n\n  if (depth > maxFenceCount) {\n    return\n  }\n\n  if (!depth || (!pedantic && value.charAt(index + 1) === numberSign)) {\n    return\n  }\n\n  length = value.length + 1\n\n  // Eat intermediate white-space.\n  queue = ''\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      index--\n      break\n    }\n\n    queue += character\n  }\n\n  // Exit when not in pedantic mode without spacing.\n  if (!pedantic && queue.length === 0 && character && character !== lineFeed) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  // Eat content.\n  subvalue += queue\n  queue = ''\n  content = ''\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (!character || character === lineFeed) {\n      break\n    }\n\n    if (character !== space && character !== tab && character !== numberSign) {\n      content += queue + character\n      queue = ''\n      continue\n    }\n\n    while (character === space || character === tab) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    // `#` without a queue is part of the content.\n    if (!pedantic && content && !queue && character === numberSign) {\n      content += character\n      continue\n    }\n\n    while (character === numberSign) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    while (character === space || character === tab) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    index--\n  }\n\n  now.column += subvalue.length\n  now.offset += subvalue.length\n  subvalue += content + queue\n\n  return eat(subvalue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}