{"ast":null,"code":"'use strict';\n\nvar trim = require('trim');\n\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = blockquote;\nvar lineFeed = '\\n';\nvar tab = '\\t';\nvar space = ' ';\nvar greaterThan = '>';\n\nfunction blockquote(eat, value, silent) {\n  var self = this;\n  var offsets = self.offset;\n  var tokenizers = self.blockTokenizers;\n  var interruptors = self.interruptBlockquote;\n  var now = eat.now();\n  var currentLine = now.line;\n  var length = value.length;\n  var values = [];\n  var contents = [];\n  var indents = [];\n  var add;\n  var index = 0;\n  var character;\n  var rest;\n  var nextIndex;\n  var content;\n  var line;\n  var startIndex;\n  var prefixed;\n  var exit;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== space && character !== tab) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (value.charAt(index) !== greaterThan) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n\n  while (index < length) {\n    nextIndex = value.indexOf(lineFeed, index);\n    startIndex = index;\n    prefixed = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== space && character !== tab) {\n        break;\n      }\n\n      index++;\n    }\n\n    if (value.charAt(index) === greaterThan) {\n      index++;\n      prefixed = true;\n\n      if (value.charAt(index) === space) {\n        index++;\n      }\n    } else {\n      index = startIndex;\n    }\n\n    content = value.slice(index, nextIndex);\n\n    if (!prefixed && !trim(content)) {\n      index = startIndex;\n      break;\n    }\n\n    if (!prefixed) {\n      rest = value.slice(index); // Check if the following code contains a possible block.\n\n      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {\n        break;\n      }\n    }\n\n    line = startIndex === index ? content : value.slice(startIndex, nextIndex);\n    indents.push(index - startIndex);\n    values.push(line);\n    contents.push(content);\n    index = nextIndex + 1;\n  }\n\n  index = -1;\n  length = indents.length;\n  add = eat(values.join(lineFeed));\n\n  while (++index < length) {\n    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];\n    currentLine++;\n  }\n\n  exit = self.enterBlock();\n  contents = self.tokenizeBlock(contents.join(lineFeed), now);\n  exit();\n  return add({\n    type: 'blockquote',\n    children: contents\n  });\n}","map":{"version":3,"sources":["F:/PorzotokFrontend/node_modules/remark-parse/lib/tokenize/blockquote.js"],"names":["trim","require","interrupt","module","exports","blockquote","lineFeed","tab","space","greaterThan","eat","value","silent","self","offsets","offset","tokenizers","blockTokenizers","interruptors","interruptBlockquote","now","currentLine","line","length","values","contents","indents","add","index","character","rest","nextIndex","content","startIndex","prefixed","exit","charAt","indexOf","slice","push","join","enterBlock","tokenizeBlock","type","children"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nvar trim = require('trim')\r\nvar interrupt = require('../util/interrupt')\r\n\r\nmodule.exports = blockquote\r\n\r\nvar lineFeed = '\\n'\r\nvar tab = '\\t'\r\nvar space = ' '\r\nvar greaterThan = '>'\r\n\r\nfunction blockquote(eat, value, silent) {\r\n  var self = this\r\n  var offsets = self.offset\r\n  var tokenizers = self.blockTokenizers\r\n  var interruptors = self.interruptBlockquote\r\n  var now = eat.now()\r\n  var currentLine = now.line\r\n  var length = value.length\r\n  var values = []\r\n  var contents = []\r\n  var indents = []\r\n  var add\r\n  var index = 0\r\n  var character\r\n  var rest\r\n  var nextIndex\r\n  var content\r\n  var line\r\n  var startIndex\r\n  var prefixed\r\n  var exit\r\n\r\n  while (index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (character !== space && character !== tab) {\r\n      break\r\n    }\r\n\r\n    index++\r\n  }\r\n\r\n  if (value.charAt(index) !== greaterThan) {\r\n    return\r\n  }\r\n\r\n  if (silent) {\r\n    return true\r\n  }\r\n\r\n  index = 0\r\n\r\n  while (index < length) {\r\n    nextIndex = value.indexOf(lineFeed, index)\r\n    startIndex = index\r\n    prefixed = false\r\n\r\n    if (nextIndex === -1) {\r\n      nextIndex = length\r\n    }\r\n\r\n    while (index < length) {\r\n      character = value.charAt(index)\r\n\r\n      if (character !== space && character !== tab) {\r\n        break\r\n      }\r\n\r\n      index++\r\n    }\r\n\r\n    if (value.charAt(index) === greaterThan) {\r\n      index++\r\n      prefixed = true\r\n\r\n      if (value.charAt(index) === space) {\r\n        index++\r\n      }\r\n    } else {\r\n      index = startIndex\r\n    }\r\n\r\n    content = value.slice(index, nextIndex)\r\n\r\n    if (!prefixed && !trim(content)) {\r\n      index = startIndex\r\n      break\r\n    }\r\n\r\n    if (!prefixed) {\r\n      rest = value.slice(index)\r\n\r\n      // Check if the following code contains a possible block.\r\n      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {\r\n        break\r\n      }\r\n    }\r\n\r\n    line = startIndex === index ? content : value.slice(startIndex, nextIndex)\r\n\r\n    indents.push(index - startIndex)\r\n    values.push(line)\r\n    contents.push(content)\r\n\r\n    index = nextIndex + 1\r\n  }\r\n\r\n  index = -1\r\n  length = indents.length\r\n  add = eat(values.join(lineFeed))\r\n\r\n  while (++index < length) {\r\n    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index]\r\n    currentLine++\r\n  }\r\n\r\n  exit = self.enterBlock()\r\n  contents = self.tokenizeBlock(contents.join(lineFeed), now)\r\n  exit()\r\n\r\n  return add({type: 'blockquote', children: contents})\r\n}\r\n"]},"metadata":{},"sourceType":"script"}