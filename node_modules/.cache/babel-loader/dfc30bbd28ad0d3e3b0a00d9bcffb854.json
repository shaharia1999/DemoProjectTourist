{"ast":null,"code":"'use strict';\n\nmodule.exports = fencedCode;\nvar lineFeed = '\\n';\nvar tab = '\\t';\nvar space = ' ';\nvar tilde = '~';\nvar graveAccent = '`';\nvar minFenceCount = 3;\nvar tabSize = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var gfm = self.options.gfm;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var lang;\n  var meta;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!gfm) {\n    return;\n  } // Eat initial spacing.\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== space && character !== tab) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index; // Eat the fence.\n\n  character = value.charAt(index);\n\n  if (character !== tilde && character !== graveAccent) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < minFenceCount) {\n    return;\n  } // Eat spacing before flag.\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== space && character !== tab) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  } // Eat flag.\n\n\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === lineFeed || marker === graveAccent && character === marker) {\n      break;\n    }\n\n    if (character === space || character === tab) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== lineFeed) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n  var skip = true; // Eat content.\n\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== lineFeed) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    } // The first line feed is ignored. Others aren’t.\n\n\n    if (skip) {\n      subvalue += character;\n      skip = false;\n    } else {\n      closing += character;\n      exdentedClosing += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== space) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= tabSize) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== space && character !== tab) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === lineFeed) {\n      break;\n    }\n  }\n\n  subvalue += content + closing; // Get lang and meta from the flag.\n\n  index = -1;\n  length = flag.length;\n\n  while (++index < length) {\n    character = flag.charAt(index);\n\n    if (character === space || character === tab) {\n      if (!lang) {\n        lang = flag.slice(0, index);\n      }\n    } else if (lang) {\n      meta = flag.slice(index);\n      break;\n    }\n  }\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: lang || flag || null,\n    meta: meta || null,\n    value: exdentedContent\n  });\n}","map":{"version":3,"sources":["F:/PorzotokFrontend/node_modules/remark-parse/lib/tokenize/code-fenced.js"],"names":["module","exports","fencedCode","lineFeed","tab","space","tilde","graveAccent","minFenceCount","tabSize","eat","value","silent","self","gfm","options","length","index","subvalue","fenceCount","marker","character","flag","lang","meta","queue","content","exdentedContent","closing","exdentedClosing","indent","now","charAt","column","offset","decode","raw","unescape","skip","slice","type"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = fencedCode\r\n\r\nvar lineFeed = '\\n'\r\nvar tab = '\\t'\r\nvar space = ' '\r\nvar tilde = '~'\r\nvar graveAccent = '`'\r\n\r\nvar minFenceCount = 3\r\nvar tabSize = 4\r\n\r\nfunction fencedCode(eat, value, silent) {\r\n  var self = this\r\n  var gfm = self.options.gfm\r\n  var length = value.length + 1\r\n  var index = 0\r\n  var subvalue = ''\r\n  var fenceCount\r\n  var marker\r\n  var character\r\n  var flag\r\n  var lang\r\n  var meta\r\n  var queue\r\n  var content\r\n  var exdentedContent\r\n  var closing\r\n  var exdentedClosing\r\n  var indent\r\n  var now\r\n\r\n  if (!gfm) {\r\n    return\r\n  }\r\n\r\n  // Eat initial spacing.\r\n  while (index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (character !== space && character !== tab) {\r\n      break\r\n    }\r\n\r\n    subvalue += character\r\n    index++\r\n  }\r\n\r\n  indent = index\r\n\r\n  // Eat the fence.\r\n  character = value.charAt(index)\r\n\r\n  if (character !== tilde && character !== graveAccent) {\r\n    return\r\n  }\r\n\r\n  index++\r\n  marker = character\r\n  fenceCount = 1\r\n  subvalue += character\r\n\r\n  while (index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (character !== marker) {\r\n      break\r\n    }\r\n\r\n    subvalue += character\r\n    fenceCount++\r\n    index++\r\n  }\r\n\r\n  if (fenceCount < minFenceCount) {\r\n    return\r\n  }\r\n\r\n  // Eat spacing before flag.\r\n  while (index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (character !== space && character !== tab) {\r\n      break\r\n    }\r\n\r\n    subvalue += character\r\n    index++\r\n  }\r\n\r\n  // Eat flag.\r\n  flag = ''\r\n  queue = ''\r\n\r\n  while (index < length) {\r\n    character = value.charAt(index)\r\n\r\n    if (\r\n      character === lineFeed ||\r\n      (marker === graveAccent && character === marker)\r\n    ) {\r\n      break\r\n    }\r\n\r\n    if (character === space || character === tab) {\r\n      queue += character\r\n    } else {\r\n      flag += queue + character\r\n      queue = ''\r\n    }\r\n\r\n    index++\r\n  }\r\n\r\n  character = value.charAt(index)\r\n\r\n  if (character && character !== lineFeed) {\r\n    return\r\n  }\r\n\r\n  if (silent) {\r\n    return true\r\n  }\r\n\r\n  now = eat.now()\r\n  now.column += subvalue.length\r\n  now.offset += subvalue.length\r\n\r\n  subvalue += flag\r\n  flag = self.decode.raw(self.unescape(flag), now)\r\n\r\n  if (queue) {\r\n    subvalue += queue\r\n  }\r\n\r\n  queue = ''\r\n  closing = ''\r\n  exdentedClosing = ''\r\n  content = ''\r\n  exdentedContent = ''\r\n  var skip = true\r\n\r\n  // Eat content.\r\n  while (index < length) {\r\n    character = value.charAt(index)\r\n    content += closing\r\n    exdentedContent += exdentedClosing\r\n    closing = ''\r\n    exdentedClosing = ''\r\n\r\n    if (character !== lineFeed) {\r\n      content += character\r\n      exdentedClosing += character\r\n      index++\r\n      continue\r\n    }\r\n\r\n    // The first line feed is ignored. Others aren’t.\r\n    if (skip) {\r\n      subvalue += character\r\n      skip = false\r\n    } else {\r\n      closing += character\r\n      exdentedClosing += character\r\n    }\r\n\r\n    queue = ''\r\n    index++\r\n\r\n    while (index < length) {\r\n      character = value.charAt(index)\r\n\r\n      if (character !== space) {\r\n        break\r\n      }\r\n\r\n      queue += character\r\n      index++\r\n    }\r\n\r\n    closing += queue\r\n    exdentedClosing += queue.slice(indent)\r\n\r\n    if (queue.length >= tabSize) {\r\n      continue\r\n    }\r\n\r\n    queue = ''\r\n\r\n    while (index < length) {\r\n      character = value.charAt(index)\r\n\r\n      if (character !== marker) {\r\n        break\r\n      }\r\n\r\n      queue += character\r\n      index++\r\n    }\r\n\r\n    closing += queue\r\n    exdentedClosing += queue\r\n\r\n    if (queue.length < fenceCount) {\r\n      continue\r\n    }\r\n\r\n    queue = ''\r\n\r\n    while (index < length) {\r\n      character = value.charAt(index)\r\n\r\n      if (character !== space && character !== tab) {\r\n        break\r\n      }\r\n\r\n      closing += character\r\n      exdentedClosing += character\r\n      index++\r\n    }\r\n\r\n    if (!character || character === lineFeed) {\r\n      break\r\n    }\r\n  }\r\n\r\n  subvalue += content + closing\r\n\r\n  // Get lang and meta from the flag.\r\n  index = -1\r\n  length = flag.length\r\n\r\n  while (++index < length) {\r\n    character = flag.charAt(index)\r\n\r\n    if (character === space || character === tab) {\r\n      if (!lang) {\r\n        lang = flag.slice(0, index)\r\n      }\r\n    } else if (lang) {\r\n      meta = flag.slice(index)\r\n      break\r\n    }\r\n  }\r\n\r\n  return eat(subvalue)({\r\n    type: 'code',\r\n    lang: lang || flag || null,\r\n    meta: meta || null,\r\n    value: exdentedContent\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}