{"ast":null,"code":"/**\r\n * @fileoverview\r\n *   Collapse whitespace.\r\n *\r\n *   Normally, collapses to a single space.\r\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\r\n *   instead of `' '`.\r\n * @example\r\n *   <h1>Heading</h1>\r\n *   <p><strong>This</strong> and <em>that</em></p>\r\n */\n'use strict';\n\nvar is = require('hast-util-is-element');\n\nvar embedded = require('hast-util-embedded');\n\nvar convert = require('unist-util-is/convert');\n\nvar whitespace = require('hast-util-whitespace');\n\nvar blocks = require('./block');\n\nvar contents = require('./content');\n\nvar skippables = require('./skippable');\n\nmodule.exports = minifyWhitespace;\nvar ignorableNode = convert(['doctype', 'comment']);\nvar parent = convert(['element', 'root']);\nvar root = convert(['root']);\nvar element = convert(['element']);\nvar text = convert(['text']);\n\nfunction minifyWhitespace(options) {\n  var collapse = collapseFactory((options || {}).newlines ? replaceNewlines : replaceWhitespace);\n  return transform;\n\n  function transform(tree) {\n    minify(tree, {\n      collapse: collapse,\n      whitespace: 'normal'\n    });\n  }\n}\n\nfunction minify(node, options) {\n  var settings;\n\n  if (parent(node)) {\n    settings = Object.assign({}, options);\n\n    if (root(node) || blocklike(node)) {\n      settings.before = true;\n      settings.after = true;\n    }\n\n    settings.whitespace = inferWhiteSpace(node, options);\n    return all(node, settings);\n  }\n\n  if (text(node)) {\n    if (options.whitespace === 'normal') {\n      return minifyText(node, options);\n    } // Naïve collapse, but no trimming:\n\n\n    if (options.whitespace === 'nowrap') {\n      node.value = options.collapse(node.value);\n    } // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n\n  }\n\n  return {\n    remove: false,\n    ignore: ignorableNode(node),\n    stripAtStart: false\n  };\n}\n\nfunction minifyText(node, options) {\n  var value = options.collapse(node.value);\n  var start = 0;\n  var end = value.length;\n  var result = {\n    remove: false,\n    ignore: false,\n    stripAtStart: false\n  };\n\n  if (options.before && removable(value.charAt(0))) {\n    start++;\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (options.after) {\n      end--;\n    } else {\n      result.stripAtStart = true;\n    }\n  }\n\n  if (start === end) {\n    result.remove = true;\n  } else {\n    node.value = value.slice(start, end);\n  }\n\n  return result;\n}\n\nfunction all(parent, options) {\n  var before = options.before;\n  var after = options.after;\n  var children = parent.children;\n  var length = children.length;\n  var index = -1;\n  var result;\n\n  while (++index < length) {\n    result = minify(children[index], Object.assign({}, options, {\n      before: before,\n      after: collapsableAfter(children, index, after)\n    }));\n\n    if (result.remove) {\n      children.splice(index, 1);\n      index--;\n      length--;\n    } else if (!result.ignore) {\n      before = result.stripAtStart;\n    } // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n\n\n    if (content(children[index])) {\n      before = false;\n    }\n  }\n\n  return {\n    remove: false,\n    ignore: false,\n    stripAtStart: before || after\n  };\n}\n\nfunction collapsableAfter(nodes, index, after) {\n  var length = nodes.length;\n  var node;\n  var result;\n\n  while (++index < length) {\n    node = nodes[index];\n    result = inferBoundary(node);\n\n    if (result === undefined && node.children && !skippable(node)) {\n      result = collapsableAfter(node.children, -1);\n    }\n\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n\n  return after;\n} // Infer two types of boundaries:\n//\n// 1. `true` — boundary for which whitespace around it does not contribute\n//    anything\n// 2. `false` — boundary for which whitespace around it *does* contribute\n//\n// No result (`undefined`) is returned if it is unknown.\n\n\nfunction inferBoundary(node) {\n  if (element(node)) {\n    if (content(node)) {\n      return false;\n    }\n\n    if (blocklike(node)) {\n      return true;\n    } // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n\n  } else if (text(node)) {\n    if (!whitespace(node)) {\n      return false;\n    }\n  } else if (!ignorableNode(node)) {\n    return false;\n  }\n} // Infer whether a node is skippable.\n\n\nfunction content(node) {\n  return embedded(node) || is(node, contents);\n} // See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n\n\nfunction blocklike(node) {\n  return is(node, blocks);\n}\n\nfunction skippable(node) {\n  /* istanbul ignore next - currently only used on elements, but just to make sure. */\n  var props = node.properties || {};\n  return ignorableNode(node) || is(node, skippables) || props.hidden;\n}\n\nfunction removable(character) {\n  return character === ' ' || character === '\\n';\n}\n\nfunction replaceNewlines(value) {\n  var match = /\\r?\\n|\\r/.exec(value);\n  return match ? match[0] : ' ';\n}\n\nfunction replaceWhitespace() {\n  return ' ';\n}\n\nfunction collapseFactory(replace) {\n  return collapse;\n\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace);\n  }\n} // We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n\n\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {};\n\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre';\n\n    case 'nobr':\n      return 'nowrap';\n\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre';\n\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : options.whitespace;\n\n    case 'textarea':\n      return 'pre-wrap';\n\n    default:\n      return options.whitespace;\n  }\n}","map":{"version":3,"sources":["F:/PorzotokFrontend/node_modules/rehype-minify-whitespace/index.js"],"names":["is","require","embedded","convert","whitespace","blocks","contents","skippables","module","exports","minifyWhitespace","ignorableNode","parent","root","element","text","options","collapse","collapseFactory","newlines","replaceNewlines","replaceWhitespace","transform","tree","minify","node","settings","Object","assign","blocklike","before","after","inferWhiteSpace","all","minifyText","value","remove","ignore","stripAtStart","start","end","length","result","removable","charAt","slice","children","index","collapsableAfter","splice","content","nodes","inferBoundary","undefined","skippable","props","properties","hidden","character","match","exec","replace","String","tagName","wrap","noWrap"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview\r\n *   Collapse whitespace.\r\n *\r\n *   Normally, collapses to a single space.\r\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\r\n *   instead of `' '`.\r\n * @example\r\n *   <h1>Heading</h1>\r\n *   <p><strong>This</strong> and <em>that</em></p>\r\n */\r\n\r\n'use strict'\r\n\r\nvar is = require('hast-util-is-element')\r\nvar embedded = require('hast-util-embedded')\r\nvar convert = require('unist-util-is/convert')\r\nvar whitespace = require('hast-util-whitespace')\r\nvar blocks = require('./block')\r\nvar contents = require('./content')\r\nvar skippables = require('./skippable')\r\n\r\nmodule.exports = minifyWhitespace\r\n\r\nvar ignorableNode = convert(['doctype', 'comment'])\r\nvar parent = convert(['element', 'root'])\r\nvar root = convert(['root'])\r\nvar element = convert(['element'])\r\nvar text = convert(['text'])\r\n\r\nfunction minifyWhitespace(options) {\r\n  var collapse = collapseFactory(\r\n    (options || {}).newlines ? replaceNewlines : replaceWhitespace\r\n  )\r\n\r\n  return transform\r\n\r\n  function transform(tree) {\r\n    minify(tree, {collapse: collapse, whitespace: 'normal'})\r\n  }\r\n}\r\n\r\nfunction minify(node, options) {\r\n  var settings\r\n\r\n  if (parent(node)) {\r\n    settings = Object.assign({}, options)\r\n\r\n    if (root(node) || blocklike(node)) {\r\n      settings.before = true\r\n      settings.after = true\r\n    }\r\n\r\n    settings.whitespace = inferWhiteSpace(node, options)\r\n\r\n    return all(node, settings)\r\n  }\r\n\r\n  if (text(node)) {\r\n    if (options.whitespace === 'normal') {\r\n      return minifyText(node, options)\r\n    }\r\n\r\n    // Naïve collapse, but no trimming:\r\n    if (options.whitespace === 'nowrap') {\r\n      node.value = options.collapse(node.value)\r\n    }\r\n\r\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\r\n    // trimmed.\r\n  }\r\n\r\n  return {\r\n    remove: false,\r\n    ignore: ignorableNode(node),\r\n    stripAtStart: false\r\n  }\r\n}\r\n\r\nfunction minifyText(node, options) {\r\n  var value = options.collapse(node.value)\r\n  var start = 0\r\n  var end = value.length\r\n  var result = {remove: false, ignore: false, stripAtStart: false}\r\n\r\n  if (options.before && removable(value.charAt(0))) {\r\n    start++\r\n  }\r\n\r\n  if (start !== end && removable(value.charAt(end - 1))) {\r\n    if (options.after) {\r\n      end--\r\n    } else {\r\n      result.stripAtStart = true\r\n    }\r\n  }\r\n\r\n  if (start === end) {\r\n    result.remove = true\r\n  } else {\r\n    node.value = value.slice(start, end)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction all(parent, options) {\r\n  var before = options.before\r\n  var after = options.after\r\n  var children = parent.children\r\n  var length = children.length\r\n  var index = -1\r\n  var result\r\n\r\n  while (++index < length) {\r\n    result = minify(\r\n      children[index],\r\n      Object.assign({}, options, {\r\n        before: before,\r\n        after: collapsableAfter(children, index, after)\r\n      })\r\n    )\r\n\r\n    if (result.remove) {\r\n      children.splice(index, 1)\r\n      index--\r\n      length--\r\n    } else if (!result.ignore) {\r\n      before = result.stripAtStart\r\n    }\r\n\r\n    // If this element, such as a `<select>` or `<img>`, contributes content\r\n    // somehow, allow whitespace again.\r\n    if (content(children[index])) {\r\n      before = false\r\n    }\r\n  }\r\n\r\n  return {\r\n    remove: false,\r\n    ignore: false,\r\n    stripAtStart: before || after\r\n  }\r\n}\r\n\r\nfunction collapsableAfter(nodes, index, after) {\r\n  var length = nodes.length\r\n  var node\r\n  var result\r\n\r\n  while (++index < length) {\r\n    node = nodes[index]\r\n    result = inferBoundary(node)\r\n\r\n    if (result === undefined && node.children && !skippable(node)) {\r\n      result = collapsableAfter(node.children, -1)\r\n    }\r\n\r\n    if (typeof result === 'boolean') {\r\n      return result\r\n    }\r\n  }\r\n\r\n  return after\r\n}\r\n\r\n// Infer two types of boundaries:\r\n//\r\n// 1. `true` — boundary for which whitespace around it does not contribute\r\n//    anything\r\n// 2. `false` — boundary for which whitespace around it *does* contribute\r\n//\r\n// No result (`undefined`) is returned if it is unknown.\r\nfunction inferBoundary(node) {\r\n  if (element(node)) {\r\n    if (content(node)) {\r\n      return false\r\n    }\r\n\r\n    if (blocklike(node)) {\r\n      return true\r\n    }\r\n\r\n    // Unknown: either depends on siblings if embedded or metadata, or on\r\n    // children.\r\n  } else if (text(node)) {\r\n    if (!whitespace(node)) {\r\n      return false\r\n    }\r\n  } else if (!ignorableNode(node)) {\r\n    return false\r\n  }\r\n}\r\n\r\n// Infer whether a node is skippable.\r\nfunction content(node) {\r\n  return embedded(node) || is(node, contents)\r\n}\r\n\r\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\r\nfunction blocklike(node) {\r\n  return is(node, blocks)\r\n}\r\n\r\nfunction skippable(node) {\r\n  /* istanbul ignore next - currently only used on elements, but just to make sure. */\r\n  var props = node.properties || {}\r\n\r\n  return ignorableNode(node) || is(node, skippables) || props.hidden\r\n}\r\n\r\nfunction removable(character) {\r\n  return character === ' ' || character === '\\n'\r\n}\r\n\r\nfunction replaceNewlines(value) {\r\n  var match = /\\r?\\n|\\r/.exec(value)\r\n  return match ? match[0] : ' '\r\n}\r\n\r\nfunction replaceWhitespace() {\r\n  return ' '\r\n}\r\n\r\nfunction collapseFactory(replace) {\r\n  return collapse\r\n  function collapse(value) {\r\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\r\n  }\r\n}\r\n\r\n// We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\r\nfunction inferWhiteSpace(node, options) {\r\n  var props = node.properties || {}\r\n\r\n  switch (node.tagName) {\r\n    case 'listing':\r\n    case 'plaintext':\r\n    case 'xmp':\r\n      return 'pre'\r\n    case 'nobr':\r\n      return 'nowrap'\r\n    case 'pre':\r\n      return props.wrap ? 'pre-wrap' : 'pre'\r\n    case 'td':\r\n    case 'th':\r\n      return props.noWrap ? 'nowrap' : options.whitespace\r\n    case 'textarea':\r\n      return 'pre-wrap'\r\n    default:\r\n      return options.whitespace\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}